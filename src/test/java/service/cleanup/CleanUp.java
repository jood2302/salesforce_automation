package service.cleanup;

import base.BaseTest;
import com.aquiva.autotests.rc.model.ngbs.dto.account.AccountSearchRequestDTO;
import com.aquiva.autotests.rc.model.prm.DealRegistrationData;
import com.aquiva.autotests.rc.utilities.salesforce.*;
import com.aquiva.autotests.rc.utilities.salesforce.sobjecthelper.DefaultBusinessIdentityMappingHelper;
import com.sforce.soap.enterprise.sobject.*;
import com.sforce.ws.ConnectionException;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

import static com.aquiva.autotests.rc.utilities.Constants.USER;
import static com.aquiva.autotests.rc.utilities.FileUtils.getBillingIdsFromTestDataFiles;
import static com.aquiva.autotests.rc.utilities.StringHelper.getSObjectIdsListAsString;
import static com.aquiva.autotests.rc.utilities.StringHelper.getStringListAsString;
import static com.aquiva.autotests.rc.utilities.ngbs.NgbsRestApiClient.searchAccountsInNGBS;
import static com.aquiva.autotests.rc.utilities.ngbs.NgbsRestApiClient.terminateAccountInNGBS;
import static com.aquiva.autotests.rc.utilities.salesforce.MetadataConnectionUtils.CRM_QA_AUTO_SUFFIX_FULLNAME;
import static com.aquiva.autotests.rc.utilities.salesforce.sobjectfactories.SubBrandsMappingFactory.SUB_BRANDS_MAPPING_DEFAULT_NAME_PREFIX;
import static com.aquiva.autotests.rc.utilities.salesforce.sobjecthelper.OrderHelper.deactivateOrder;
import static io.qameta.allure.Allure.step;
import static java.lang.Boolean.parseBoolean;
import static java.lang.Integer.parseInt;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;

/**
 * Special task for removing SFDC records generated by automated tests from the test sandbox.
 */
public class CleanUp extends BaseTest {
    private static final Logger LOGGER = LoggerFactory.getLogger(CleanUp.class);

    /**
     * A default limit on delete by IDs operation since API v.7.0 = 200.
     * Can be lowered via this parameter to minimize the execution time for deletion.
     */
    private static final int BATCH_SIZE_ON_DELETE = parseInt(System.getProperty("batchSizeOnDelete", "200"));
    private static final boolean IS_MVP_ACCOUNTS_TERMINATION = parseBoolean(System.getProperty("isMvpAccountsTermination", "true"));
    private static final boolean IS_ENGAGE_ACCOUNTS_TERMINATION = parseBoolean(System.getProperty("isEngageAccountsTermination", "true"));
    private static final boolean IS_RC_CC_ACCOUNTS_TERMINATION = parseBoolean(System.getProperty("isRcCcAccountsTermination", "true"));

    private final EnterpriseConnectionUtils enterpriseConnectionUtils;
    private final MetadataConnectionUtils metadataConnectionUtils;
    private final ToolingConnectionUtils toolingConnectionUtils;

    private final List<Throwable> exceptions;

    private List<Lead> leadsToConvert;
    private Set<String> convertedAccountsIds;
    private Set<String> allTestAccountIds;
    private String allTestAccountIdsListAsString;
    private String testUserId;

    public CleanUp() {
        enterpriseConnectionUtils = EnterpriseConnectionUtils.getInstance();
        metadataConnectionUtils = MetadataConnectionUtils.getInstance();
        toolingConnectionUtils = ToolingConnectionUtils.getInstance();

        exceptions = new ArrayList<>();
    }

    @Test
    @DisplayName("Clean up SFDC records generated by the Automation tests")
    public void test() {
        step("1. Get the the test User's Salesforce Id", () -> {
            var testUser = enterpriseConnectionUtils.querySingleRecord(
                    "SELECT Id " +
                            "FROM User " +
                            "WHERE Username = '" + USER + "'",
                    User.class);
            testUserId = testUser.getId();
        });

        step("2. Terminate Engage Accounts created as Single Product or part of Multi-Product " +
                "in NGBS System created by the test user in SFDC", () -> {
            if (IS_ENGAGE_ACCOUNTS_TERMINATION) {
                step("Terminate Engage Accounts created as Single Product in NGBS system created by the test user in SFDC", () -> {
                    var engageAccountsSingleProduct = enterpriseConnectionUtils.query(
                            "SELECT Id, Billing_ID__c, RC_User_ID__c " +
                                    "FROM Account " +
                                    "WHERE CreatedById = '" + testUserId + "' " +
                                    "AND IsMultiProductTechnicalAccount__c = false " +
                                    "AND Billing_ID__c != null " +
                                    "AND Service_Type__c LIKE 'Engage%' " +
                                    "LIMIT 2000",
                            Account.class);
                    LOGGER.info("Found {} Engage Accounts records created by the test user through Single Product flow",
                            engageAccountsSingleProduct.size());

                    terminateEngageAccountsInNGBS(engageAccountsSingleProduct);
                });

                step("Terminate Engage Accounts created as part of Multi-Product in NGBS system created by the test user in SFDC", () -> {
                    var engageAccountsMultiProduct = enterpriseConnectionUtils.query(
                            "SELECT Id, Billing_ID__c, RC_User_ID__c " +
                                    "FROM Account " +
                                    "WHERE Master_Account__c IN " +
                                    "(SELECT AccountId " +
                                    "FROM Opportunity " +
                                    "WHERE Account.CreatedById = '" + testUserId + "' " +
                                    "AND Account.IsMultiProductTechnicalAccount__c = false " +
                                    "AND Account.Billing_ID__c != null) " +
                                    "AND IsMultiProductTechnicalAccount__c = true " +
                                    "AND Billing_ID__c != null " +
                                    "AND Service_Type__c LIKE 'Engage%' " +
                                    "LIMIT 2000",
                            Account.class);
                    LOGGER.info("Found {} Engage Accounts records created by the test user through Multi-Product flow",
                            engageAccountsMultiProduct.size());

                    terminateEngageAccountsInNGBS(engageAccountsMultiProduct);
                });
            } else {
                LOGGER.info("Engage Accounts termination is disabled. Skipping the step...");
                step("Engage Accounts termination is disabled. Skipping the step...");
            }
        });

        step("3. Terminate RC CC Accounts in NGBS created by the test user", () -> {
            if (IS_RC_CC_ACCOUNTS_TERMINATION) {
                var masterAccountsCreatedByTestUserIds = enterpriseConnectionUtils.query(
                        "SELECT Id " +
                                "FROM Account " +
                                "WHERE CreatedById = '" + testUserId + "' " +
                                "AND IsMultiProductTechnicalAccount__c = false " +
                                "AND Billing_ID__c != null " +
                                "LIMIT 2000",
                        Account.class);

                var rcCcTechAccounts = enterpriseConnectionUtils.query(
                        "SELECT Id, Billing_ID__c " +
                                "FROM Account " +
                                "WHERE Master_Account__c IN " +
                                getSObjectIdsListAsString(masterAccountsCreatedByTestUserIds) + " " +
                                "AND IsMultiProductTechnicalAccount__c = true " +
                                "AND Billing_ID__c != null " +
                                "AND Service_Type__c = 'RingCentral Contact Center' " +
                                "LIMIT 2000",
                        Account.class);
                LOGGER.info("Found {} RC CC Tech Accounts records created by the test user",
                        rcCcTechAccounts.size());

                var listOfRcCcBillingIdsFromSfdcAccounts = rcCcTechAccounts
                        .stream()
                        .map(Account::getBilling_ID__c)
                        .toList();

                terminateAccountsInNGBS(listOfRcCcBillingIdsFromSfdcAccounts);
            } else {
                LOGGER.info("RingCentral Contact Center Accounts termination is disabled. Skipping the step...");
                step("RingCentral Contact Center Accounts termination is disabled. Skipping the step...");
            }
        });

        step("4. Terminate MVP Accounts in NGBS created by the test user", () -> {
            if (IS_MVP_ACCOUNTS_TERMINATION) {
                var mvpExistingBusinessAccounts = enterpriseConnectionUtils.query(
                        "SELECT Id, Billing_ID__c " +
                                "FROM Account " +
                                "WHERE CreatedById = '" + testUserId + "' " +
                                "AND Billing_ID__c != null " +
                                "AND IsMultiProductTechnicalAccount__c = false " +
                                "AND Service_Type__c IN ('Office', '') " +
                                "LIMIT 2000",
                        Account.class);
                LOGGER.info("Found {} Existing Business MVP Account records created by the test user (in SFDC)",
                        mvpExistingBusinessAccounts.size());

                var listOfBillingIdsFromSfdcAccounts = mvpExistingBusinessAccounts
                        .stream()
                        .map(Account::getBilling_ID__c)
                        .toList();
                LOGGER.info("List of the Billing IDs from the Existing Business MVP Accounts in SFDC: " + listOfBillingIdsFromSfdcAccounts);

                var listOfBillingIdsToExcludeFromTermination = getBillingIdsFromTestDataFiles();
                LOGGER.info("List of the Billing IDs to exclude from termination: " + listOfBillingIdsToExcludeFromTermination);

                var listOfBillingIdsForTermination = listOfBillingIdsFromSfdcAccounts
                        .stream()
                        .filter(billingIdFromSfdcAccount -> !listOfBillingIdsToExcludeFromTermination.contains(billingIdFromSfdcAccount))
                        .distinct()
                        .toList();
                LOGGER.info("List of the Billing IDs for termination in NGBS: " + listOfBillingIdsForTermination);

                LOGGER.info("Number of MVP Accounts for termination in NGBS: " + listOfBillingIdsForTermination.size());
                step("Number of MVP Accounts for termination in NGBS: " + listOfBillingIdsForTermination.size());
                terminateAccountsInNGBS(listOfBillingIdsForTermination);
            } else {
                LOGGER.info("MVP Accounts termination is disabled. Skipping the step...");
                step("MVP Accounts termination is disabled. Skipping the step...");
            }
        });

        step("5. Delete test Account and Lead records created by the test user " +
                "and other records related to the test Accounts", () -> {
            try {
                deleteTestAccountsLeadsAndRelatedRecords();
            } catch (Exception e) {
                LOGGER.error("Error has occurred while deleting test Accounts and/or related records!", e);
                exceptions.add(e);
            }
        });

        step("6. Delete other test records created by the test user and NOT related to the test Accounts", () -> {
            step("Delete ContentDocument records (uploaded file attachments) created by the test user", () -> {
                var createdAttachments = enterpriseConnectionUtils.query(
                        "SELECT Id " +
                                "FROM ContentDocument " +
                                "WHERE OwnerId = '" + testUserId + "' " +
                                "LIMIT 2000",
                        ContentDocument.class);
                LOGGER.info("Found {} ContentDocument records (uploaded file attachments) uploaded by the test user",
                        createdAttachments.size());

                deleteByBatches(createdAttachments);
            });

            step("Delete Document__c records created by the test user", () -> {
                var documents = enterpriseConnectionUtils.query(
                        "SELECT Id " +
                                "FROM Document__c " +
                                "WHERE CreatedById = '" + testUserId + "' " +
                                "LIMIT 2000",
                        Document__c.class);
                LOGGER.info("Found {} Document__c records created by the test user", documents.size());

                deleteByBatches(documents);
            });

            step("Delete EventLog__c records created by the test user", () -> {
                var eventLogs = enterpriseConnectionUtils.query(
                        "SELECT Id " +
                                "FROM EventLog__c " +
                                "WHERE CreatedById = '" + testUserId + "' " +
                                "LIMIT 2000",
                        EventLog__c.class);
                LOGGER.info("Found {} EventLog__c records created by the test user", eventLogs.size());

                deleteByBatches(eventLogs);
            });

            step("Delete Exception_And_Notification_History__c records created by the test user", () -> {
                var createdExceptionAndNotificationHistoryObjects = enterpriseConnectionUtils.query(
                        "SELECT Id " +
                                "FROM Exception_And_Notification_History__c " +
                                "WHERE OwnerId = '" + testUserId + "' " +
                                "LIMIT 2000",
                        Exception_And_Notification_History__c.class);
                LOGGER.info("Found {} Exception_And_Notification_History__c records created by the test user",
                        createdExceptionAndNotificationHistoryObjects.size());

                deleteByBatches(createdExceptionAndNotificationHistoryObjects);
            });

            step("Delete Demand_Funnel__c records created by the test user", () -> {
                var createdDemandFunnelObjects = enterpriseConnectionUtils.query(
                        "SELECT Id " +
                                "FROM Demand_Funnel__c " +
                                "WHERE OwnerId = '" + testUserId + "' " +
                                "LIMIT 2000",
                        Demand_Funnel__c.class);
                LOGGER.info("Found {} Demand_Funnel__c records created by the test user",
                        createdDemandFunnelObjects.size());

                deleteByBatches(createdDemandFunnelObjects);
            });

            step("Delete INVOCA_FOR_SF__Invoca_Conversion_Reporting__c records created by the test user", () -> {
                var createdInvocaConversionReportingObjects = enterpriseConnectionUtils.query(
                        "SELECT Id " +
                                "FROM INVOCA_FOR_SF__Invoca_Conversion_Reporting__c " +
                                "WHERE OwnerId = '" + testUserId + "' " +
                                "LIMIT 2000",
                        INVOCA_FOR_SF__Invoca_Conversion_Reporting__c.class);
                LOGGER.info("Found {} INVOCA_FOR_SF__Invoca_Conversion_Reporting__c records created by the test user",
                        createdInvocaConversionReportingObjects.size());

                deleteByBatches(createdInvocaConversionReportingObjects);
            });

            step("Delete ObjectMonitoring__c records created by the test user", () -> {
                var createdObjectMonitoringObjects = enterpriseConnectionUtils.query(
                        "SELECT Id " +
                                "FROM ObjectMonitoring__c " +
                                "WHERE OwnerId = '" + testUserId + "' " +
                                "LIMIT 2000",
                        ObjectMonitoring__c.class);
                LOGGER.info("Found {} ObjectMonitoring__c records created by the test user",
                        createdObjectMonitoringObjects.size());

                deleteByBatches(createdObjectMonitoringObjects);
            });

            step("Delete Contact_Ext__c records created by the test user", () -> {
                var createdContactExtObjects = enterpriseConnectionUtils.query(
                        "SELECT Id " +
                                "FROM Contact_Ext__c " +
                                "WHERE OwnerId = '" + testUserId + "' " +
                                "LIMIT 2000",
                        Contact_Ext__c.class);
                LOGGER.info("Found {} Contact_Ext__c records created by the test user",
                        createdContactExtObjects.size());

                deleteByBatches(createdContactExtObjects);
            });

            step("Delete Lead_Ext__c records created by the test user", () -> {
                var createdLeadExtObjects = enterpriseConnectionUtils.query(
                        "SELECT Id " +
                                "FROM Lead_Ext__c " +
                                "WHERE OwnerId = '" + testUserId + "' " +
                                "LIMIT 2000",
                        Lead_Ext__c.class);
                LOGGER.info("Found {} Lead_Ext__c records created by the test user",
                        createdLeadExtObjects.size());

                deleteByBatches(createdLeadExtObjects);
            });

            step("Delete SubBrandsMapping__c records created by the test user", () -> {
                var createdSubBrandsMappingObjects = enterpriseConnectionUtils.query(
                        "SELECT Id " +
                                "FROM SubBrandsMapping__c " +
                                "WHERE CreatedById = '" + testUserId + "' " +
                                "OR Name LIKE '" + SUB_BRANDS_MAPPING_DEFAULT_NAME_PREFIX + "%' " +
                                "LIMIT 2000",
                        SubBrandsMapping__c.class);
                LOGGER.info("Found {} SubBrandsMapping__c records created by the autotests",
                        createdSubBrandsMappingObjects.size());

                deleteByBatches(createdSubBrandsMappingObjects);
            });

            step("Delete Default_Business_Identity_Mapping__mdt records created by the autotests", () -> {
                var createdDefaultBiMappingMdtRecords = enterpriseConnectionUtils.query(
                        "SELECT Id, DeveloperName " +
                                "FROM Default_Business_Identity_Mapping__mdt " +
                                "WHERE DeveloperName LIKE '%" + CRM_QA_AUTO_SUFFIX_FULLNAME + "' " +
                                "LIMIT 2000",
                        Default_Business_Identity_Mapping__mdt.class);
                LOGGER.info("Found {} Default_Business_Identity_Mapping__mdt records created by the autotests",
                        createdDefaultBiMappingMdtRecords.size());

                if (!createdDefaultBiMappingMdtRecords.isEmpty()) {
                    var createdDefaultBiMappingMdtRecordsFullNames = createdDefaultBiMappingMdtRecords
                            .stream()
                            .map(DefaultBusinessIdentityMappingHelper::getFullName)
                            .collect(toList());
                    deleteByBatches(createdDefaultBiMappingMdtRecordsFullNames, BATCH_SIZE_ON_DELETE, true);
                }
            });
        });

        checkAndThrowExceptions();
    }

    /**
     * Check for exceptions during the script execution
     * and throw a {@link RuntimeException} to mark the CI build as FAILURE.
     */
    private void checkAndThrowExceptions() {
        if (!exceptions.isEmpty()) {
            exceptions.forEach(ex -> LOGGER.error("Exception during the Clean Up execution: " + ex));
            throw new RuntimeException("There are errors during the Clean Up execution! Check the logs for details!");
        }
    }

    /**
     * Delete test Account and Lead records created by the test user
     * and other records related to the test Accounts.
     */
    private void deleteTestAccountsLeadsAndRelatedRecords() {
        step("Search for test Leads created for conversion and their converted Accounts", () -> {
            leadsToConvert = enterpriseConnectionUtils.query(
                    "SELECT Id, ConvertedAccountId " +
                            "FROM Lead " +
                            "WHERE CreatedById = '" + testUserId + "' " +
                            "LIMIT 2000",
                    Lead.class);
            LOGGER.info("Found {} test Leads", leadsToConvert.size());

            convertedAccountsIds = leadsToConvert.stream()
                    .map(Lead::getConvertedAccountId)
                    .filter(id -> id != null)
                    .collect(toSet());

            //  to check that the converted accounts still exist and not deleted separately before that
            var convertedAccountsIdsListAsString = getStringListAsString(convertedAccountsIds);
            var existingConvertedAccounts = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Account " +
                            "WHERE Id IN " + convertedAccountsIdsListAsString + " " +
                            "LIMIT 2000",
                    Account.class);
            convertedAccountsIds = existingConvertedAccounts.stream()
                    .map(SObject::getId)
                    .collect(toSet());

            LOGGER.info("Found {} Account records converted from the test Leads", convertedAccountsIds.size());
        });

        step("Search for the existing test Accounts", () -> {
            var accounts = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Account " +
                            "WHERE CreatedById = '" + testUserId + "' " +
                            "AND IsMultiProductTechnicalAccount__c = false " +
                            "LIMIT 2000",
                    Account.class);
            LOGGER.info("Found {} test Accounts", accounts.size());

            step("Merge existing test Accounts with Accounts converted from test Leads " +
                    "into 'All test Accounts' list", () -> {
                allTestAccountIds = accounts.stream()
                        .map(Account::getId)
                        .collect(toSet());
                allTestAccountIds.addAll(convertedAccountsIds);
                allTestAccountIdsListAsString = getStringListAsString(allTestAccountIds);
            });
        });

        if (allTestAccountIds.isEmpty()) {
            LOGGER.info("Test accounts are not found! Terminating step's execution...");
            return;
        }

        step("Delete Area_Code_Line_Item__c records related to the test Accounts", () -> {
            var areaCodeLineItems = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Area_Code_Line_Item__c " +
                            "WHERE Quote_Line_Item__r.Quote.AccountId IN " + allTestAccountIdsListAsString + " " +
                            "AND Quote_Line_Item__r.IsMultiProductTechnicalQLI__c = false " +
                            "LIMIT 2000",
                    Area_Code_Line_Item__c.class);
            LOGGER.info("Found {} Area_Code_Line_Item__c records related to the test Accounts", areaCodeLineItems.size());

            deleteByBatches(areaCodeLineItems);
        });

        step("Delete AssignmentLineItem__c records related to the test Accounts", () -> {
            var assignmentLineItemsParent = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM AssignmentLineItem__c " +
                            "WHERE Parent__r.Quote.Account__c IN " + allTestAccountIdsListAsString + " " +
                            "AND Parent__r.IsMultiProductTechnicalQLI__c = false " +
                            "LIMIT 2000",
                    AssignmentLineItem__c.class);
            var assignmentLineItemsChild = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM AssignmentLineItem__c " +
                            "WHERE Child__r.Quote.Account__c IN " + allTestAccountIdsListAsString + " " +
                            "AND Child__r.IsMultiProductTechnicalQLI__c = false " +
                            "LIMIT 2000",
                    AssignmentLineItem__c.class);

            var createdAssignmentLineItems = new ArrayList<AssignmentLineItem__c>();
            createdAssignmentLineItems.addAll(assignmentLineItemsParent);
            createdAssignmentLineItems.addAll(assignmentLineItemsChild);
            var assignmentLineItemUniqueIds = createdAssignmentLineItems.stream()
                    .map(SObject::getId)
                    .collect(toSet());

            LOGGER.info("Found {} AssignmentLineItem__c records related to the test Accounts",
                    assignmentLineItemUniqueIds.size());

            deleteByBatches(assignmentLineItemUniqueIds);
        });

        step("Delete Case records related to the test Accounts", () -> {
            var casesForMasterAccounts = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Case " +
                            "WHERE AccountId IN " + allTestAccountIdsListAsString + " " +
                            "LIMIT 2000",
                    Case.class);
            var casesForTechAccounts = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Case " +
                            "WHERE Account.Master_Account__c IN " + allTestAccountIdsListAsString + " " +
                            "LIMIT 2000",
                    Case.class);
            var casesForTestContacts = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Case " +
                            "WHERE Contact.AccountId IN " + allTestAccountIdsListAsString + " " +
                            "LIMIT 2000",
                    Case.class);

            var cases = new ArrayList<Case>();
            cases.addAll(casesForMasterAccounts);
            cases.addAll(casesForTechAccounts);
            cases.addAll(casesForTestContacts);

            LOGGER.info("Found {} Case records related to the test Accounts", cases.size());

            deleteByBatches(cases);
        });

        step("Delete Approval__c records related to the test Accounts", () -> {
            var approvals = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Approval__c " +
                            "WHERE Account__c IN " + allTestAccountIdsListAsString + " " +
                            "AND IsMultiProductTechnicalApproval__c = false " +
                            "LIMIT 2000",
                    Approval__c.class);
            LOGGER.info("Found {} Approval__c records related to the test Accounts", approvals.size());

            deleteByBatches(approvals);
        });

        step("Delete Contract records related to the test Accounts", () -> {
            var contracts = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Contract " +
                            "WHERE AccountId IN " + allTestAccountIdsListAsString + " " +
                            "LIMIT 2000",
                    Contract.class);
            LOGGER.info("Found {} Contract records related to the test Accounts", contracts.size());

            deleteByBatches(contracts);
        });

        step("Delete closed Opportunity records related to the test Accounts", () -> {
            var closedOpportunitiesMaster = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Opportunity " +
                            "WHERE IsClosed = true " +
                            "AND AccountId IN " + allTestAccountIdsListAsString + " " +
                            "LIMIT 2000",
                    Opportunity.class);
            var closedOpportunitiesTech = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Opportunity " +
                            "WHERE IsClosed = true " +
                            "AND IsMultiProductTechnicalOpportunity__c = true " +
                            "AND Account.Master_Account__c IN " + allTestAccountIdsListAsString + " " +
                            "LIMIT 2000",
                    Opportunity.class);

            var closedOpportunities = new ArrayList<Opportunity>();
            closedOpportunities.addAll(closedOpportunitiesMaster);
            closedOpportunities.addAll(closedOpportunitiesTech);

            LOGGER.info("Found {} closed Opportunity records related to the test Accounts", closedOpportunities.size());

            //  TODO remove (or leave) after the resolving of BZS-11108
            deleteByBatches(closedOpportunities, 30);
        });

        step("Delete test Lead records created for conversion", () -> {
            LOGGER.info("Deleting test Leads created for conversion...");
            deleteByBatches(leadsToConvert);
        });

        step("Delete AccountRelation__c records related to the test Accounts", () -> {
            var createdAccountRelationsViaParentAccount = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM AccountRelation__c " +
                            "WHERE Parent_Account__c IN " + allTestAccountIdsListAsString + " " +
                            "LIMIT 2000",
                    AccountRelation__c.class);
            var createdAccountRelationsViaChildAccount = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM AccountRelation__c " +
                            "WHERE Child_Account__c IN " + allTestAccountIdsListAsString + " " +
                            "LIMIT 2000",
                    AccountRelation__c.class);

            var createdAccountRelations = new ArrayList<AccountRelation__c>();
            createdAccountRelations.addAll(createdAccountRelationsViaParentAccount);
            createdAccountRelations.addAll(createdAccountRelationsViaChildAccount);

            LOGGER.info("Found {} AccountRelation__c records related to the test Accounts",
                    createdAccountRelations.size());

            deleteByBatches(createdAccountRelations);
        });

        step("Delete Package__c records (Billing Account Packages) related to the test Accounts", () -> {
            var createdServiceAccounts = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Package__c " +
                            "WHERE Account__c IN " + allTestAccountIdsListAsString + " " +
                            "LIMIT 2000",
                    Package__c.class);
            LOGGER.info("Found {} Package__c records (Billing Account Packages) related to the test Accounts",
                    createdServiceAccounts.size());

            deleteByBatches(createdServiceAccounts);
        });

        step("Delete Order records related to the test Accounts", () -> {
            var ordersForMasterAccounts = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Order " +
                            "WHERE AccountId IN " + allTestAccountIdsListAsString + " " +
                            "LIMIT 2000",
                    Order.class);
            LOGGER.info("Found {} Order records related to the test Accounts (Master)",
                    ordersForMasterAccounts.size());

            var ordersForTechAccounts = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Order " +
                            "WHERE Account.Master_Account__c IN " + allTestAccountIdsListAsString + " " +
                            "AND Account.IsMultiProductTechnicalAccount__c = true " +
                            "LIMIT 2000",
                    Order.class);
            LOGGER.info("Found {} Order records related to the test Accounts (Tech)",
                    ordersForTechAccounts.size());

            var orders = new ArrayList<Order>();
            orders.addAll(ordersForMasterAccounts);
            orders.addAll(ordersForTechAccounts);

            LOGGER.info("Found {} Order records related to the test Accounts (all)", orders.size());

            //  Orders with Status = 'Activated'/'Submitted' cannot be deleted, they should be in different status for deletion, e.g. 'New'
            orders.forEach(order -> deactivateOrder(order));
            updateByBatches(orders, BATCH_SIZE_ON_DELETE);

            deleteByBatches(orders);
        });

        step("Delete Deal_Registration__c records related to the test Accounts or created via PRM Portal", () -> {
            var dealRegistrations = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Deal_Registration__c " +
                            "WHERE Partner_Account__c IN " + allTestAccountIdsListAsString + " " +
                            "OR Last_Name__c LIKE '%" + DealRegistrationData.AUTOTEST_SUFFIX + "%' " +
                            "LIMIT 2000",
                    Deal_Registration__c.class);
            LOGGER.info("Found {} Deal_Registration__c records related to the test Accounts or created via PRM Portal",
                    dealRegistrations.size());

            deleteByBatches(dealRegistrations);
        });

        step("Delete Entitlement records (Support Entitlements) with related Cases related to the test Accounts", () -> {
            var entitlements = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Entitlement " +
                            "WHERE AccountId IN " + allTestAccountIdsListAsString + " " +
                            "LIMIT 2000",
                    Entitlement.class);
            LOGGER.info("Found {} Entitlement records related to the test Accounts", entitlements.size());

            if (!entitlements.isEmpty()) {
                var casesRelatedToEntitlements = enterpriseConnectionUtils.query(
                        "SELECT Id " +
                                "FROM Case " +
                                "WHERE EntitlementId IN " + getSObjectIdsListAsString(entitlements) + " " +
                                "LIMIT 2000",
                        Case.class);
                LOGGER.info("Found {} Case records related to the Entitlement records", casesRelatedToEntitlements.size());
                deleteByBatches(casesRelatedToEntitlements);
            }

            deleteByBatches(entitlements);
        });

        step("Delete LocalSubscribedAddress__c records related to the test Accounts or created by the test user", () -> {
            var localSubscribedAddresses = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM LocalSubscribedAddress__c " +
                            "WHERE Approval__r.Account__c IN " + allTestAccountIdsListAsString + " " +
                            "OR CreatedById = '" + testUserId + "' " +
                            "LIMIT 2000",
                    LocalSubscribedAddress__c.class);
            LOGGER.info("Found {} LocalSubscribedAddress__c records related to the test Accounts and/or created by test user",
                    localSubscribedAddresses.size());

            deleteByBatches(localSubscribedAddresses);
        });

        //  Accounts created for Engage/Contact Center services as a part of MultiProduct Quote creation
        step("Delete Technical Accounts related to the test Accounts", () -> {
            var techAccounts = enterpriseConnectionUtils.query(
                    "SELECT Id " +
                            "FROM Account " +
                            "WHERE Master_Account__c IN " + allTestAccountIdsListAsString + " " +
                            "AND IsMultiProductTechnicalAccount__c = true " +
                            "LIMIT 2000",
                    Account.class);
            LOGGER.info("Found {} Technical Account records related to the test Accounts",
                    techAccounts.size());

            deleteByBatches(techAccounts);
        });

        step("Delete all test Accounts", () -> {
            LOGGER.info("Deleting test Accounts...");
            deleteByBatches(allTestAccountIds);
        });
    }

    /**
     * Terminate Engage test Accounts in NGBS created by the test user.
     *
     * @param accounts collection of Accounts that need to be terminated
     */
    private void terminateEngageAccountsInNGBS(List<Account> accounts) {
        accounts.forEach(account -> {
            var billingId = account.getBilling_ID__c();
            var rcUserId = account.getRC_User_ID__c();

            var code = """
                    public class CcbResponseException extends Exception {}
                    
                    class EngageAccountRequestParams {
                        public String opportunityId;
                        public String ngbsPackageId;
                        public Map<String, String> salesAgentInfo;
                    }
                                        
                    BillingWrappers.NGBSAccount ngbsAcc;
                    try {
                        ngbsAcc = NGBSAPI.getNGBSAccount('%s');
                    } catch (Exception e) {
                        System.debug(e);
                    }
                    EngageAccountRequestParams params = new EngageAccountRequestParams();
                    params.opportunityId = '10%s';
                    params.ngbsPackageId = ngbsAcc.getPackage().id;
                    params.salesAgentInfo = new Map<String, String> {
                        'id' => UserInfo.getUserId(),
                        'name' => UserInfo.getUserName()
                    };
                    CCB_Settings__c settings = CCB_Settings__c.getInstance();
                    String endpoint = settings.DirectBaseEndpoint__c + settings.APIVersion2Path__c + settings.TerminationPath__c + '/' + '%s';
                    HttpResponse httpResp = CCBAPI.requestCCB(endpoint, HttpHelper.METHOD_PUT, JSON.serialize(params));
                                        
                    if (httpResp.getStatusCode() >= 400 && httpResp.getStatusCode() <= 599 ) {
                        throw new CcbResponseException('CCB response contains a client/server error. ' +
                                            'HttpResponse: ' + httpResp + '; ' +
                                           	'Response Body: ' + httpResp.getBody());
                    }
                    """.formatted(billingId, billingId, rcUserId);
            try {
                LOGGER.info("Terminating an Engage Account in NGBS {SFDC Id = '{}', Billing_ID__c = '{}', RC_User_ID__c = '{}'} ...",
                        account.getId(), billingId, rcUserId);
                toolingConnectionUtils.executeAnonymousApex(code);
            } catch (Exception e) {
                LOGGER.error("Error has occurred while terminating an Engage Account!", e);
                exceptions.add(e);
            }
        });
    }

    /**
     * Terminate Accounts in NGBS using their Billing IDs.
     *
     * @param listOfBillingIdsForTermination list of Billing IDs for termination
     */
    private void terminateAccountsInNGBS(List<String> listOfBillingIdsForTermination) {
        for (var billingId : listOfBillingIdsForTermination) {
            try {
                LOGGER.info("Searching an Account in NGBS with Billing ID = {} ...", billingId);
                var searchRequest = AccountSearchRequestDTO.byBillingId(billingId);
                var foundAccounts = searchAccountsInNGBS(searchRequest);

                if (foundAccounts.isEmpty()) {
                    LOGGER.info("Cannot find an Account in NGBS with Billing ID = {}!", billingId);
                } else {
                    LOGGER.info("Terminating an Account in NGBS with Billing ID = {} ...", billingId);
                    terminateAccountInNGBS(billingId);
                }
            } catch (AssertionError e) {
                LOGGER.error("Error has occurred while terminating the Account!", e);
                exceptions.add(e);
            }
        }
    }

    /**
     * Update records by batches of the custom size.
     *
     * @param sObjects  collection of SObjects that need to be updated
     * @param batchSize number of records in a single batch to update
     * @throws ConnectionException in case of errors while accessing API
     */
    private <T extends SObject> void updateByBatches(Collection<T> sObjects, int batchSize) throws ConnectionException {
        var sObjectToUpdate = new ArrayList<>(sObjects);

        while (!sObjectToUpdate.isEmpty()) {
            var elementsBatch = sObjectToUpdate.stream()
                    .limit(batchSize)
                    .collect(toSet());
            sObjectToUpdate.removeAll(elementsBatch);

            LOGGER.info("Update a batch of {} record(s)...", elementsBatch.size());
            enterpriseConnectionUtils.update(elementsBatch);

            LOGGER.info("Successfully updated a batch of {} record(s): {}",
                    elementsBatch.size(), elementsBatch.stream().map(SObject::getId).toList());
            LOGGER.info("Remaining number of records to update: " + sObjectToUpdate.size());
        }
    }

    /**
     * Delete records by batches of the custom size using their IDs.
     *
     * @param recordIds set of IDs for records that need to be deleted
     *                  (SObject IDs or Custom Metadata Type full names)
     * @param batchSize number of records in a single batch to delete
     * @throws ConnectionException in case of errors while accessing API
     */
    private void deleteByBatches(Collection<String> recordIds, int batchSize, boolean isCustomMetadata) throws ConnectionException {
        while (!recordIds.isEmpty()) {
            var elementsBatch = recordIds.stream()
                    .limit(batchSize)
                    .collect(toSet());
            recordIds.removeAll(elementsBatch);

            LOGGER.info("Deleting a batch of {} record(s)...", elementsBatch.size());
            if (isCustomMetadata) {
                metadataConnectionUtils.deleteCustomMetadataRecords(elementsBatch.stream().toList());
            } else {
                enterpriseConnectionUtils.deleteByIds(elementsBatch);
            }

            LOGGER.info("Successfully deleted a batch of {} record(s): {}",
                    elementsBatch.size(), elementsBatch);
            LOGGER.info("Remaining number of records to delete: " + recordIds.size());
        }
    }

    /**
     * Delete SObjects by batches of the fixed size using their IDs.
     *
     * @param sObjectIds set of IDs for SObjects that need to be deleted
     * @throws ConnectionException in case of errors while accessing API
     */
    private void deleteByBatches(Set<String> sObjectIds) throws ConnectionException {
        deleteByBatches(sObjectIds, BATCH_SIZE_ON_DELETE, false);
    }

    /**
     * Delete SObjects by batches of the fixed size.
     *
     * @param sObjects collection of SObjects that need to be deleted
     * @param <T>      any SObject type, like Lead, Account, Contact, Opportunity...
     * @throws ConnectionException in case of errors while accessing API
     */
    private <T extends SObject> void deleteByBatches(Collection<T> sObjects) throws ConnectionException {
        deleteByBatches(sObjects, BATCH_SIZE_ON_DELETE);
    }

    /**
     * Delete SObjects by batches of the custom size.
     *
     * @param sObjects  collection of SObjects that need to be deleted
     * @param batchSize number of records in a single batch to delete
     * @param <T>       any SObject type, like Lead, Account, Contact, Opportunity...
     * @throws ConnectionException in case of errors while accessing API
     */
    private <T extends SObject> void deleteByBatches(Collection<T> sObjects, int batchSize) throws ConnectionException {
        var sObjectIds = sObjects.stream()
                .map(SObject::getId)
                .collect(toSet());

        deleteByBatches(sObjectIds, batchSize, false);
    }
}
